<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Logit Lens Visualization Preview</title>
    <script src="preview_data.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1000px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { font-size: 24px; margin-bottom: 20px; }
        .preview-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .note { font-size: 12px; color: #666; margin-bottom: 15px; }
    </style>
</head>
<body>
    <h1>Logit Lens Visualization Preview</h1>
    <p class="note">Using real Llama 3.1 70B data via NDIF. Open in browser - no notebook needed.</p>
    <div class="preview-container" id="viz"></div>

<script>
// Use real data from NDIF via JSONP (preview_data.js)
const data = (typeof PREVIEW_DATA !== 'undefined') ? PREVIEW_DATA : {
    layers: [0, 1, 2, 3],
    tokens: ["Fallback", " data"],
    cells: [[{token:"test",prob:0.5,trajectory:[0.5,0.5,0.5,0.5],topk:[{token:"test",prob:0.5,trajectory:[0.5,0.5,0.5,0.5]}]}]]
};

// Widget factory - each call creates an independent instance
var LogitLensWidget = (function() {
    var instanceCount = 0;

    return function(containerId, widgetData) {
        var uid = "ll_interact_" + instanceCount++;
        var container = document.getElementById(containerId);
        if (!container) {
            console.error("Container not found:", containerId);
            return;
        }

        // Inject scoped CSS
        var style = document.createElement("style");
        style.textContent = `
            #${uid} {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                margin: 20px 0;
                position: relative;
                -webkit-user-select: none;
                user-select: none;
            }
            #${uid} .ll-title { font-size: 16px; font-weight: 600; margin-bottom: 8px; }
            #${uid} .color-mode-btn {
                display: inline-block; padding: 2px 4px; background: white;
                border-radius: 4px; font-size: 16px; cursor: pointer; color: #333;
                border: 1px solid #ccc;
            }
            #${uid} .color-mode-btn:hover { background: #f5f5f5; }
            #${uid} .ll-table { border-collapse: collapse; font-size: 10px; table-layout: fixed; }
            #${uid} .ll-table td, #${uid} .ll-table th { border: 1px solid #ddd; box-sizing: border-box; }
            #${uid} .pred-cell {
                height: 22px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
                padding: 2px 4px; font-family: monospace; font-size: 9px; cursor: pointer; position: relative;
            }
            #${uid} .pred-cell:hover { outline: 2px solid #e91e63; outline-offset: -1px; }
            #${uid} .pred-cell.selected { background: #fff59d !important; color: #333 !important; }
            #${uid} .input-token {
                padding: 2px 8px; text-align: right; font-weight: 500; color: #333;
                background: #f5f5f5; white-space: nowrap; overflow: hidden;
                text-overflow: ellipsis; font-family: monospace; font-size: 10px; cursor: pointer;
                position: relative;
            }
            #${uid} .input-token:hover { background: #e8e8e8; }
            #${uid} .layer-hdr {
                padding: 4px 2px; text-align: center; font-weight: 500; color: #666;
                background: #f5f5f5; font-size: 9px; position: relative;
            }
            #${uid} .corner-hdr { padding: 4px 8px; text-align: right; font-weight: 500; color: #666; background: white; position: relative; }
            #${uid} .chart-container { margin-top: 8px; background: #fafafa; border-radius: 4px; padding: 8px 0; }
            #${uid} .chart-container svg { display: block; margin: 0; padding: 0; }
            #${uid} .popup {
                display: none; position: absolute; background: white; border: 1px solid #ddd;
                border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px;
                z-index: 100; min-width: 180px; max-width: 280px;
            }
            #${uid} .popup.visible { display: block; }
            #${uid} .popup-header { font-weight: 600; font-size: 13px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee; }
            #${uid} .popup-header code { font-weight: 400; font-size: 12px; background: #f5f5f5; padding: 2px 6px; border-radius: 3px; margin-left: 4px; }
            #${uid} .popup-close { position: absolute; top: 8px; right: 10px; cursor: pointer; color: #999; font-size: 16px; }
            #${uid} .popup-close:hover { color: #333; }
            #${uid} .topk-item {
                padding: 4px 6px; margin: 2px 0; border-radius: 3px; cursor: pointer;
                display: flex; justify-content: space-between; font-size: 11px;
            }
            #${uid} .topk-item:hover { background: #e3f2fd; }
            #${uid} .topk-item.active { background: #bbdefb; }
            #${uid} .topk-token { font-family: monospace; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            #${uid} .topk-prob { color: #666; margin-left: 8px; }
            #${uid} .topk-item.pinned { border-left: 3px solid currentColor; }
            #${uid} .resize-handle {
                position: absolute; width: 6px; height: 100%; background: transparent;
                cursor: col-resize; right: -3px; top: 0; z-index: 10;
            }
            #${uid} .resize-handle:hover, #${uid} .resize-handle.dragging { background: rgba(33, 150, 243, 0.4); }
            #${uid} .resize-handle-input {
                position: absolute; width: 6px; height: 100%; background: transparent;
                cursor: col-resize; right: -3px; top: 0; z-index: 10;
            }
            #${uid} .resize-handle-input:hover, #${uid} .resize-handle-input.dragging { background: rgba(76, 175, 80, 0.4); }
            #${uid} .table-wrapper { position: relative; display: inline-block; }
            #${uid} .resize-handle-bottom {
                position: absolute; bottom: 0; left: 0; right: 0; height: 6px;
                cursor: row-resize; background: transparent;
            }
            #${uid} .resize-handle-bottom:hover, #${uid} .resize-handle-bottom.dragging { background: rgba(33, 150, 243, 0.4); }
            #${uid} .resize-hint { font-size: 9px; color: #999; margin-top: 4px; }
            #${uid} .color-menu {
                display: none; position: absolute; background: white; border: 1px solid #ddd;
                border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 200; min-width: 150px;
            }
            #${uid} .color-menu.visible { display: block; }
            #${uid} .color-menu-item { padding: 8px 12px; cursor: pointer; font-size: 12px; }
            #${uid} .color-menu-item:hover { background: #f0f0f0; }
            #${uid} .legend-close { cursor: pointer; }
            #${uid} .legend-close:hover { fill: #e91e63 !important; }
        `;
        document.head.appendChild(style);

        // Inject HTML structure
        container.innerHTML = `
            <div id="${uid}">
                <div class="ll-title" id="${uid}_title">Logit Lens: Top Predictions by Layer</div>
                <div class="table-wrapper">
                    <table class="ll-table" id="${uid}_table"></table>
                    <div class="resize-handle-bottom" id="${uid}_resize_bottom"></div>
                </div>
                <div class="resize-hint" id="${uid}_resize_hint">drag column borders to resize</div>
                <div class="chart-container" id="${uid}_chart_container">
                    <svg id="${uid}_chart" height="140"></svg>
                </div>
                <div class="popup" id="${uid}_popup">
                    <span class="popup-close" id="${uid}_popup_close">&times;</span>
                    <div class="popup-header">
                        Layer <span id="${uid}_popup_layer"></span>, Position <span id="${uid}_popup_pos"></span>
                    </div>
                    <div id="${uid}_popup_content"></div>
                </div>
                <div class="color-menu" id="${uid}_color_menu"></div>
            </div>
        `;

        // Widget logic (same as original, just using uid and widgetData)
        (function() {
            var nLayers = widgetData.layers.length;
            var chartHeight = 140;
            var chartMargin = { top: 10, right: 8, bottom: 25, left: 10 };
            var chartInnerHeight = chartHeight - chartMargin.top - chartMargin.bottom;
            var minCellWidth = 10;
            var maxCellWidth = 200;

            var inputTokenWidth = 100;
            var currentCellWidth = 44;
            var currentVisibleIndices = [];
            var currentMaxRows = null;
            var openPopupCell = null;
            var currentHoverPos = widgetData.tokens.length - 1;
            var colorMode = "top";

            var pinnedGroups = [];
            var lastPinnedGroupIndex = -1;
            var colors = ["#2196F3", "#e91e63", "#4CAF50", "#FF9800", "#9C27B0", "#00BCD4", "#F44336", "#8BC34A"];
            var colorIndex = 0;

            function getNextColor() {
                var c = colors[colorIndex % colors.length];
                colorIndex++;
                return c;
            }

            function getColorForToken(token) {
                for (var i = 0; i < pinnedGroups.length; i++) {
                    if (pinnedGroups[i].tokens.indexOf(token) >= 0) return pinnedGroups[i].color;
                }
                return null;
            }

            function findGroupForToken(token) {
                for (var i = 0; i < pinnedGroups.length; i++) {
                    if (pinnedGroups[i].tokens.indexOf(token) >= 0) return i;
                }
                return -1;
            }

            function getGroupLabel(group) {
                return group.tokens.map(function(t) { return visualizeSpaces(t); }).join("+");
            }

            function getGroupTrajectory(group, pos) {
                var result = widgetData.layers.map(function() { return 0; });
                for (var i = 0; i < group.tokens.length; i++) {
                    var traj = getTrajectoryForToken(group.tokens[i], pos);
                    for (var j = 0; j < result.length; j++) {
                        result[j] += traj[j];
                    }
                }
                return result;
            }

            function getGroupProbAtLayer(group, pos, layerIdx) {
                var sum = 0;
                for (var i = 0; i < group.tokens.length; i++) {
                    var traj = getTrajectoryForToken(group.tokens[i], pos);
                    sum += traj[layerIdx] || 0;
                }
                return sum;
            }

            function getWinningGroupAtCell(pos, layerIdx) {
                var cellData = widgetData.cells[pos][layerIdx];
                var top1Prob = cellData.prob;
                var winningGroup = null;
                var winningProb = top1Prob;

                for (var i = 0; i < pinnedGroups.length; i++) {
                    var groupProb = getGroupProbAtLayer(pinnedGroups[i], pos, layerIdx);
                    if (groupProb > winningProb) {
                        winningProb = groupProb;
                        winningGroup = pinnedGroups[i];
                    }
                }
                return winningGroup;
            }

            function escapeHtml(text) {
                var div = document.createElement("div");
                div.textContent = text;
                return div.innerHTML;
            }

            function visualizeSpaces(text) {
                var result = text;
                var leadingSpaces = 0;
                while (leadingSpaces < result.length && result[leadingSpaces] === ' ') leadingSpaces++;
                if (leadingSpaces > 0) {
                    result = '\u02FD'.repeat(leadingSpaces) + result.slice(leadingSpaces);
                }
                var trailingSpaces = 0;
                while (trailingSpaces < result.length && result[result.length - 1 - trailingSpaces] === ' ') trailingSpaces++;
                if (trailingSpaces > 0) {
                    result = result.slice(0, result.length - trailingSpaces) + '\u02FD'.repeat(trailingSpaces);
                }
                return result;
            }

            function probToColor(prob, baseColor) {
                if (baseColor) {
                    var hex = baseColor.replace('#', '');
                    var r = parseInt(hex.substr(0, 2), 16);
                    var g = parseInt(hex.substr(2, 2), 16);
                    var b = parseInt(hex.substr(4, 2), 16);
                    var blend = prob;
                    var rr = Math.round(255 - (255 - r) * blend);
                    var gg = Math.round(255 - (255 - g) * blend);
                    var bb = Math.round(255 - (255 - b) * blend);
                    return "rgb(" + rr + "," + gg + "," + bb + ")";
                }
                var rVal = Math.round(255 * (1 - prob * 0.8));
                var gVal = Math.round(255 * (1 - prob * 0.6));
                return "rgb(" + rVal + "," + gVal + ",255)";
            }

            function getTrajectoryForToken(token, pos) {
                for (var li = 0; li < widgetData.cells[pos].length; li++) {
                    var cellData = widgetData.cells[pos][li];
                    if (cellData.token === token) return cellData.trajectory;
                    for (var ki = 0; ki < cellData.topk.length; ki++) {
                        if (cellData.topk[ki].token === token) return cellData.topk[ki].trajectory;
                    }
                }
                return widgetData.layers.map(function() { return 0; });
            }

            function computeVisibleLayers(cellWidth, containerWidth) {
                var availableWidth = containerWidth - inputTokenWidth - 1;
                var maxCols = Math.max(1, Math.floor(availableWidth / cellWidth));

                if (maxCols >= nLayers) {
                    return { stride: 1, indices: widgetData.layers.map(function(_, i) { return i; }) };
                }

                var stride = maxCols > 1
                    ? Math.max(1, Math.floor((nLayers - 1) / (maxCols - 1)))
                    : nLayers;

                var indices = [];
                var lastLayer = nLayers - 1;
                for (var i = lastLayer; i >= 0; i -= stride) {
                    indices.unshift(i);
                }

                while (indices.length > maxCols) {
                    indices.shift();
                }

                return { stride: stride, indices: indices };
            }

            function updateChartDimensions() {
                var table = document.getElementById(uid + "_table");
                var tableWidth = table.offsetWidth;
                var svg = document.getElementById(uid + "_chart");
                svg.setAttribute("width", tableWidth);

                var firstInputCell = table.querySelector(".input-token");
                if (firstInputCell) {
                    var tableRect = table.getBoundingClientRect();
                    var inputCellRect = firstInputCell.getBoundingClientRect();
                    var actualInputRight = inputCellRect.right - tableRect.left;
                    return tableWidth - actualInputRight;
                }
                return tableWidth - inputTokenWidth;
            }

            function buildTable(cellWidth, visibleLayerIndices, maxRows) {
                currentVisibleIndices = visibleLayerIndices;
                currentMaxRows = maxRows;
                var table = document.getElementById(uid + "_table");
                var html = "";

                var totalTokens = widgetData.tokens.length;
                var visiblePositions;
                if (maxRows === null || maxRows >= totalTokens) {
                    visiblePositions = widgetData.tokens.map(function(_, i) { return i; });
                } else {
                    var startPos = totalTokens - maxRows;
                    visiblePositions = [];
                    for (var i = startPos; i < totalTokens; i++) {
                        visiblePositions.push(i);
                    }
                }

                html += "<colgroup>";
                html += '<col style="width:' + inputTokenWidth + 'px;">';
                visibleLayerIndices.forEach(function() {
                    html += '<col style="width:' + cellWidth + 'px;">';
                });
                html += "</colgroup>";

                var halfwayCol = Math.floor(visibleLayerIndices.length / 2);

                // Get base color for heatmap (if colorMode is a pinned token)
                var colorModeBaseColor = colorMode !== "top" ? getColorForToken(colorMode) : null;

                visiblePositions.forEach(function(pos, rowIdx) {
                    var tok = widgetData.tokens[pos];
                    var isFirstVisibleRow = rowIdx === 0;
                    html += "<tr>";
                    html += '<td class="input-token" data-pos="' + pos + '" title="' + escapeHtml(tok) + '" style="width:' + inputTokenWidth + 'px; max-width:' + inputTokenWidth + 'px;">';
                    html += escapeHtml(tok);
                    if (isFirstVisibleRow) {
                        html += '<div class="resize-handle-input" data-col="-1"></div>';
                    }
                    html += '</td>';

                    visibleLayerIndices.forEach(function(li, colIdx) {
                        var cellData = widgetData.cells[pos][li];
                        var cellProb = colorMode === "top" ? cellData.prob :
                            (cellData.topk.find(function(t) { return t.token === colorMode; }) || {prob: 0}).prob;

                        var color = probToColor(cellProb, colorModeBaseColor);
                        var textColor = cellProb < 0.5 ? "#333" : "#fff";
                        var pinnedColor = getColorForToken(cellData.token);
                        if (!pinnedColor) {
                            var winningGroup = getWinningGroupAtCell(pos, li);
                            if (winningGroup) pinnedColor = winningGroup.color;
                        }
                        var pinnedStyle = pinnedColor ? "box-shadow: inset 0 0 0 2px " + pinnedColor + ";" : "";

                        var hasHandle = isFirstVisibleRow && colIdx < halfwayCol;

                        html += '<td class="pred-cell' + (pinnedColor ? ' pinned' : '') + '" ' +
                            'data-pos="' + pos + '" data-li="' + li + '" data-col="' + colIdx + '" ' +
                            'style="background:' + color + '; color:' + textColor + '; width:' + cellWidth + 'px; max-width:' + cellWidth + 'px; ' + pinnedStyle + '">' +
                            escapeHtml(cellData.token);
                        if (hasHandle) {
                            html += '<div class="resize-handle" data-col="' + colIdx + '"></div>';
                        }
                        html += '</td>';
                    });
                    html += "</tr>";
                });

                html += "<tr>";
                html += '<th class="corner-hdr" style="width:' + inputTokenWidth + 'px; max-width:' + inputTokenWidth + 'px;">Layer<div class="resize-handle-input" data-col="-1"></div></th>';
                visibleLayerIndices.forEach(function(li, colIdx) {
                    var hasHandle = colIdx < halfwayCol;
                    html += '<th class="layer-hdr" style="width:' + cellWidth + 'px; max-width:' + cellWidth + 'px;">' + widgetData.layers[li];
                    if (hasHandle) {
                        html += '<div class="resize-handle" data-col="' + colIdx + '"></div>';
                    }
                    html += '</th>';
                });
                html += "</tr>";

                table.innerHTML = html;
                attachCellListeners();
                attachResizeListeners();

                var containerWidth = getContainerWidth();
                var actualTableWidth = table.offsetWidth;
                if (actualTableWidth > containerWidth) {
                    console.log("Table width overflow detected:", {
                        containerWidth: containerWidth,
                        actualTableWidth: actualTableWidth,
                        overflow: actualTableWidth - containerWidth
                    });
                }

                var chartInnerWidth = updateChartDimensions();
                drawAllTrajectories(null, null, null, chartInnerWidth, currentHoverPos);
                updateTitle();

                var hint = document.getElementById(uid + "_resize_hint");
                var stride = visibleLayerIndices.length < nLayers ? Math.ceil(nLayers / visibleLayerIndices.length) : 1;
                hint.textContent = stride > 1 ?
                    "showing every " + stride + " layers ending at " + (nLayers-1) + " (drag column borders to adjust)" :
                    "showing all " + nLayers + " layers";
            }

            function updateTitle() {
                var titleEl = document.getElementById(uid + "_title");
                var displayLabel = "Top prediction";
                var pinnedColor = null;

                if (colorMode !== "top") {
                    var groupIdx = findGroupForToken(colorMode);
                    if (groupIdx >= 0) {
                        var group = pinnedGroups[groupIdx];
                        displayLabel = getGroupLabel(group);
                        pinnedColor = group.color;
                    } else {
                        displayLabel = visualizeSpaces(colorMode);
                    }
                }

                var btnStyle = pinnedColor ? "background: " + pinnedColor + "22; border-color: " + pinnedColor + ";" : "";

                titleEl.innerHTML = 'Logit Lens: Top Predictions by Layer <span class="color-mode-btn" id="' + uid + '_color_btn" style="' + btnStyle + '">(' + escapeHtml(displayLabel) + ')</span>';
                document.getElementById(uid + "_color_btn").addEventListener("click", showColorModeMenu);
            }

            function showColorModeMenu(e) {
                e.stopPropagation();
                var menu = document.getElementById(uid + "_color_menu");
                var btn = e.target;
                var rect = btn.getBoundingClientRect();
                var containerRect = document.getElementById(uid).getBoundingClientRect();

                menu.style.left = (rect.left - containerRect.left) + "px";
                menu.style.top = (rect.bottom - containerRect.top + 5) + "px";

                var lastPos = widgetData.tokens.length - 1;
                var lastLayerIdx = currentVisibleIndices[currentVisibleIndices.length - 1];
                var topToken = widgetData.cells[lastPos][lastLayerIdx].token;

                var html = '<div class="color-menu-item" data-mode="top">Top prediction</div>';

                if (findGroupForToken(topToken) < 0) {
                    html += '<div class="color-menu-item" data-mode="' + escapeHtml(topToken) + '">' + escapeHtml(topToken) + '</div>';
                }

                pinnedGroups.forEach(function(group) {
                    var label = getGroupLabel(group);
                    var modeToken = group.tokens[0];
                    html += '<div class="color-menu-item" data-mode="' + escapeHtml(modeToken) + '" style="border-left: 3px solid ' + group.color + ';">' + escapeHtml(label) + '</div>';
                });

                menu.innerHTML = html;
                menu.classList.add("visible");

                menu.querySelectorAll(".color-menu-item").forEach(function(item) {
                    item.addEventListener("click", function(ev) {
                        ev.stopPropagation();
                        colorMode = item.dataset.mode;
                        menu.classList.remove("visible");
                        buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                    });
                });
            }

            function getContainerWidth() {
                var el = document.getElementById(uid);
                return el.offsetWidth || 900;
            }

            // Shared drag state for column resizing (prevents listener accumulation)
            var colResizeDrag = { active: false, type: null, startX: 0, startWidth: 0, colIdx: 0 };
            var yAxisDrag = { active: false, startX: 0, startWidth: 0 };

            function attachResizeListeners() {
                document.querySelectorAll("#" + uid + " .resize-handle-input").forEach(function(handle) {
                    handle.addEventListener("mousedown", function(e) {
                        closePopup();
                        colResizeDrag = { active: true, type: 'input', startX: e.clientX, startWidth: inputTokenWidth, colIdx: 0 };
                        handle.classList.add("dragging");
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                document.querySelectorAll("#" + uid + " .resize-handle").forEach(function(handle) {
                    var colIdx = parseInt(handle.dataset.col);
                    handle.addEventListener("mousedown", function(e) {
                        closePopup();
                        colResizeDrag = { active: true, type: 'column', startX: e.clientX, startWidth: currentCellWidth, colIdx: colIdx };
                        handle.classList.add("dragging");
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
            }

            // Single document-level listeners for column resize (added once per widget)
            document.addEventListener("mousemove", function(e) {
                if (!colResizeDrag.active) return;
                var delta = e.clientX - colResizeDrag.startX;

                if (colResizeDrag.type === 'input') {
                    inputTokenWidth = Math.max(40, Math.min(200, colResizeDrag.startWidth + delta));
                    var result = computeVisibleLayers(currentCellWidth, getContainerWidth());
                    buildTable(currentCellWidth, result.indices, currentMaxRows);
                } else if (colResizeDrag.type === 'column') {
                    var numCols = colResizeDrag.colIdx + 1;
                    var widthDelta = delta / numCols;
                    var newWidth = Math.max(minCellWidth, Math.min(maxCellWidth, colResizeDrag.startWidth + widthDelta));
                    if (Math.abs(newWidth - currentCellWidth) > 1) {
                        currentCellWidth = newWidth;
                        var result = computeVisibleLayers(currentCellWidth, getContainerWidth());
                        buildTable(currentCellWidth, result.indices, currentMaxRows);
                    }
                }
            });

            document.addEventListener("mouseup", function() {
                if (colResizeDrag.active) {
                    colResizeDrag.active = false;
                    document.querySelectorAll("#" + uid + " .resize-handle-input, #" + uid + " .resize-handle").forEach(function(h) {
                        h.classList.remove("dragging");
                    });
                }
                if (yAxisDrag.active) {
                    yAxisDrag.active = false;
                }
            });

            document.addEventListener("mousemove", function(e) {
                if (!yAxisDrag.active) return;
                var delta = e.clientX - yAxisDrag.startX;
                inputTokenWidth = Math.max(40, Math.min(200, yAxisDrag.startWidth + delta));
                var result = computeVisibleLayers(currentCellWidth, getContainerWidth());
                buildTable(currentCellWidth, result.indices, currentMaxRows);
            });

            function attachCellListeners() {
                document.querySelectorAll("#" + uid + " .pred-cell, #" + uid + " .input-token").forEach(function(cell) {
                    var pos = parseInt(cell.dataset.pos);
                    if (isNaN(pos)) return;

                    cell.addEventListener("mouseenter", function() {
                        currentHoverPos = pos;
                        var li = cell.dataset.li ? parseInt(cell.dataset.li) : 0;
                        var cellData = widgetData.cells[pos][li] || widgetData.cells[pos][0];
                        var chartInnerWidth = updateChartDimensions();
                        var isPinned = findGroupForToken(cellData.token) >= 0;
                        var hoverTraj = isPinned ? null : cellData.trajectory;
                        var hoverColor = isPinned ? null : "#999";
                        var hoverLabel = isPinned ? null : cellData.token;
                        drawAllTrajectories(hoverTraj, hoverColor, hoverLabel, chartInnerWidth, pos);
                    });
                });

                document.querySelectorAll("#" + uid + " .pred-cell").forEach(function(cell) {
                    var pos = parseInt(cell.dataset.pos);
                    var li = parseInt(cell.dataset.li);
                    var cellData = widgetData.cells[pos][li];

                    cell.addEventListener("click", function(e) {
                        e.stopPropagation();
                        var addToGroup = e.shiftKey || e.ctrlKey || e.metaKey;
                        if (e.shiftKey) {
                            togglePinnedTrajectory(cellData.token, addToGroup);
                            buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                            return;
                        }
                        if (openPopupCell === cell) { closePopup(); return; }
                        document.querySelectorAll("#" + uid + " .pred-cell.selected").forEach(function(c) { c.classList.remove("selected"); });
                        cell.classList.add("selected");
                        showPopup(cell, pos, li, cellData);
                    });
                });

                document.getElementById(uid + "_popup_close").addEventListener("click", closePopup);
            }

            function closePopup() {
                document.getElementById(uid + "_popup").classList.remove("visible");
                document.querySelectorAll("#" + uid + " .pred-cell.selected").forEach(function(c) { c.classList.remove("selected"); });
                openPopupCell = null;
            }

            function showPopup(cell, pos, li, cellData) {
                openPopupCell = cell;
                var popup = document.getElementById(uid + "_popup");
                var rect = cell.getBoundingClientRect();
                var containerRect = document.getElementById(uid).getBoundingClientRect();

                popup.style.left = (rect.left - containerRect.left + rect.width + 5) + "px";
                popup.style.top = (rect.top - containerRect.top) + "px";

                document.getElementById(uid + "_popup_layer").textContent = widgetData.layers[li];
                document.getElementById(uid + "_popup_pos").innerHTML = pos + "<br>Input <code>" + escapeHtml(visualizeSpaces(widgetData.tokens[pos])) + "</code>";

                var contentHtml = "";
                cellData.topk.forEach(function(item, ki) {
                    var probPct = (item.prob * 100).toFixed(1);
                    var pinnedColor = getColorForToken(item.token);
                    var pinnedStyle = pinnedColor ? "background: " + pinnedColor + "22; border-left-color: " + pinnedColor + ";" : "";
                    var visualizedToken = visualizeSpaces(item.token);
                    contentHtml += '<div class="topk-item' + (pinnedColor ? ' pinned' : '') + '" data-ki="' + ki + '" style="' + pinnedStyle + '">';
                    contentHtml += '<span class="topk-token" title="' + escapeHtml(visualizedToken) + '">' + escapeHtml(visualizedToken) + '</span>';
                    contentHtml += '<span class="topk-prob">' + probPct + '%</span>';
                    contentHtml += '</div>';
                });

                document.getElementById(uid + "_popup_content").innerHTML = contentHtml;

                document.querySelectorAll("#" + uid + "_popup_content .topk-item").forEach(function(item) {
                    var ki = parseInt(item.dataset.ki);
                    var tokData = cellData.topk[ki];

                    item.addEventListener("mouseenter", function() {
                        document.querySelectorAll("#" + uid + "_popup_content .topk-item").forEach(function(it) { it.classList.remove("active"); });
                        item.classList.add("active");
                        var chartInnerWidth = updateChartDimensions();
                        var isPinned = findGroupForToken(tokData.token) >= 0;
                        var hoverTraj = isPinned ? null : tokData.trajectory;
                        drawAllTrajectories(hoverTraj, "#999", tokData.token, chartInnerWidth, pos);
                    });

                    item.addEventListener("mouseleave", function() {
                        var chartInnerWidth = updateChartDimensions();
                        drawAllTrajectories(null, null, null, chartInnerWidth, pos);
                    });

                    item.addEventListener("click", function(e) {
                        e.stopPropagation();
                        var addToGroup = e.shiftKey || e.ctrlKey || e.metaKey;
                        togglePinnedTrajectory(tokData.token, addToGroup);
                        buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                        var newCell = document.querySelector("#" + uid + " .pred-cell[data-pos='" + pos + "'][data-li='" + li + "']");
                        if (newCell) {
                            newCell.classList.add("selected");
                            showPopup(newCell, pos, li, cellData);
                        }
                    });
                });

                popup.classList.add("visible");
                var chartInnerWidth = updateChartDimensions();
                var isPinned = findGroupForToken(cellData.token) >= 0;
                var hoverTraj = isPinned ? null : cellData.trajectory;
                drawAllTrajectories(hoverTraj, "#999", cellData.token, chartInnerWidth, pos);
            }

            function togglePinnedTrajectory(token, addToGroup) {
                var existingGroupIdx = findGroupForToken(token);

                if (addToGroup && lastPinnedGroupIndex >= 0 && lastPinnedGroupIndex < pinnedGroups.length) {
                    var lastGroup = pinnedGroups[lastPinnedGroupIndex];

                    if (existingGroupIdx === lastPinnedGroupIndex) {
                        lastGroup.tokens = lastGroup.tokens.filter(function(t) { return t !== token; });
                        if (lastGroup.tokens.length === 0) {
                            pinnedGroups.splice(lastPinnedGroupIndex, 1);
                            lastPinnedGroupIndex = pinnedGroups.length - 1;
                        }
                        return false;
                    } else if (existingGroupIdx >= 0) {
                        pinnedGroups[existingGroupIdx].tokens = pinnedGroups[existingGroupIdx].tokens.filter(function(t) { return t !== token; });
                        if (pinnedGroups[existingGroupIdx].tokens.length === 0) {
                            pinnedGroups.splice(existingGroupIdx, 1);
                            if (lastPinnedGroupIndex > existingGroupIdx) lastPinnedGroupIndex--;
                        }
                        lastGroup.tokens.push(token);
                        return true;
                    } else {
                        lastGroup.tokens.push(token);
                        return true;
                    }
                } else {
                    if (existingGroupIdx >= 0) {
                        var group = pinnedGroups[existingGroupIdx];
                        group.tokens = group.tokens.filter(function(t) { return t !== token; });
                        if (group.tokens.length === 0) {
                            pinnedGroups.splice(existingGroupIdx, 1);
                            if (lastPinnedGroupIndex >= pinnedGroups.length) {
                                lastPinnedGroupIndex = pinnedGroups.length - 1;
                            }
                        }
                        return false;
                    } else {
                        var newGroup = { color: getNextColor(), tokens: [token] };
                        pinnedGroups.push(newGroup);
                        lastPinnedGroupIndex = pinnedGroups.length - 1;
                        return true;
                    }
                }
            }

            function drawAllTrajectories(hoverTrajectory, hoverColor, hoverLabel, chartInnerWidth, pos) {
                var svg = document.getElementById(uid + "_chart");
                svg.innerHTML = "";

                var table = document.getElementById(uid + "_table");
                var firstInputCell = table.querySelector(".input-token");
                var tableRect = table.getBoundingClientRect();
                var inputCellRect = firstInputCell.getBoundingClientRect();
                var actualInputRight = inputCellRect.right - tableRect.left;

                var legendG = document.createElementNS("http://www.w3.org/2000/svg", "g");
                legendG.setAttribute("class", "legend-area");
                svg.appendChild(legendG);

                var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("transform", "translate(" + actualInputRight + "," + chartMargin.top + ")");
                svg.appendChild(g);

                var xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
                xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", chartInnerHeight);
                xAxis.setAttribute("x2", chartInnerWidth); xAxis.setAttribute("y2", chartInnerHeight);
                xAxis.setAttribute("stroke", "#ccc");
                g.appendChild(xAxis);

                var dotRadius = 3;
                var labelMargin = chartMargin.right;
                var usableWidth = chartInnerWidth - labelMargin;
                function layerToXForLabels(layerIdx) {
                    if (nLayers <= 1) return usableWidth / 2;
                    return dotRadius + (layerIdx / (nLayers - 1)) * (usableWidth - 2 * dotRadius);
                }

                var minLabelSpacing = 25;
                var totalLabelsWidth = currentVisibleIndices.length * minLabelSpacing;
                var labelStride = 1;
                if (totalLabelsWidth > usableWidth) {
                    labelStride = Math.ceil(totalLabelsWidth / usableWidth);
                }

                var lastIdx = currentVisibleIndices.length - 1;
                var showAtIndex = new Set();
                for (var i = lastIdx; i >= 0; i -= labelStride) {
                    showAtIndex.add(i);
                }
                showAtIndex.add(0);
                if (labelStride > 1) {
                    for (var i = lastIdx; i > 0; i -= labelStride) {
                        if (i < labelStride) {
                            showAtIndex.delete(i);
                            break;
                        }
                    }
                }

                currentVisibleIndices.forEach(function(layerIdx, i) {
                    if (showAtIndex.has(i)) {
                        var x = layerToXForLabels(layerIdx);
                        var label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        label.setAttribute("x", x);
                        label.setAttribute("y", chartInnerHeight + 12);
                        label.setAttribute("text-anchor", "middle");
                        label.setAttribute("font-size", "9");
                        label.setAttribute("fill", "#666");
                        label.textContent = widgetData.layers[layerIdx];
                        g.appendChild(label);
                    }
                });

                var yAxisGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                yAxisGroup.style.cursor = "col-resize";

                var yAxisHitTarget = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                yAxisHitTarget.setAttribute("x", -4); yAxisHitTarget.setAttribute("y", 0);
                yAxisHitTarget.setAttribute("width", 8); yAxisHitTarget.setAttribute("height", chartInnerHeight);
                yAxisHitTarget.setAttribute("fill", "transparent");
                yAxisGroup.appendChild(yAxisHitTarget);

                var yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
                yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0);
                yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", chartInnerHeight);
                yAxis.setAttribute("stroke", "#ccc");
                yAxisGroup.appendChild(yAxis);
                g.appendChild(yAxisGroup);

                yAxisGroup.addEventListener("mousedown", function(e) {
                    closePopup();
                    yAxisDrag = { active: true, startX: e.clientX, startWidth: inputTokenWidth };
                    yAxis.setAttribute("stroke", "rgba(76, 175, 80, 0.6)");
                    e.preventDefault();
                    e.stopPropagation();
                });

                var yLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                yLabel.setAttribute("x", -chartInnerHeight / 2);
                yLabel.setAttribute("y", -actualInputRight + 15);
                yLabel.setAttribute("text-anchor", "middle");
                yLabel.setAttribute("font-size", "10");
                yLabel.setAttribute("fill", "#666");
                yLabel.setAttribute("transform", "rotate(-90)");
                yLabel.textContent = "Probability";
                svg.appendChild(yLabel);

                var allProbs = [];
                pinnedGroups.forEach(function(group) {
                    var traj = getGroupTrajectory(group, pos);
                    allProbs = allProbs.concat(traj);
                });
                if (hoverTrajectory) allProbs = allProbs.concat(hoverTrajectory);
                var maxProb = Math.max.apply(null, allProbs.concat([0.1]));

                var legendY = chartMargin.top + 10;
                pinnedGroups.forEach(function(group, groupIdx) {
                    var traj = getGroupTrajectory(group, pos);
                    var groupLabel = getGroupLabel(group);
                    drawSingleTrajectory(g, traj, group.color, maxProb, groupLabel, false, chartInnerWidth);

                    var legendItem = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    legendItem.setAttribute("transform", "translate(18, " + legendY + ")");
                    legendItem.style.cursor = "pointer";

                    var hitTarget = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    hitTarget.setAttribute("x", "-15"); hitTarget.setAttribute("y", "-8");
                    hitTarget.setAttribute("width", inputTokenWidth - 5); hitTarget.setAttribute("height", "14");
                    hitTarget.setAttribute("fill", "transparent");
                    legendItem.appendChild(hitTarget);

                    var closeBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    closeBtn.setAttribute("class", "legend-close");
                    closeBtn.setAttribute("x", "-12"); closeBtn.setAttribute("y", "4");
                    closeBtn.setAttribute("font-size", "16"); closeBtn.setAttribute("fill", "#999");
                    closeBtn.style.display = "none";
                    closeBtn.textContent = "\u00d7";
                    legendItem.appendChild(closeBtn);

                    var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", "0"); line.setAttribute("y1", "0");
                    line.setAttribute("x2", "15"); line.setAttribute("y2", "0");
                    line.setAttribute("stroke", group.color); line.setAttribute("stroke-width", "2");
                    legendItem.appendChild(line);

                    var clipId = uid + "_legend_clip_" + groupIdx;
                    var clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                    clipPath.setAttribute("id", clipId);
                    var clipRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    clipRect.setAttribute("x", "20"); clipRect.setAttribute("y", "-10");
                    clipRect.setAttribute("width", inputTokenWidth - 45); clipRect.setAttribute("height", "20");
                    clipPath.appendChild(clipRect);
                    legendItem.appendChild(clipPath);

                    var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", "20"); text.setAttribute("y", "4");
                    text.setAttribute("font-size", "9"); text.setAttribute("fill", "#333");
                    text.setAttribute("clip-path", "url(#" + clipId + ")");
                    text.textContent = groupLabel;
                    legendItem.appendChild(text);

                    legendItem.addEventListener("mouseenter", function() { closeBtn.style.display = "block"; });
                    legendItem.addEventListener("mouseleave", function() { closeBtn.style.display = "none"; });
                    closeBtn.addEventListener("click", function(e) {
                        e.stopPropagation();
                        pinnedGroups.splice(groupIdx, 1);
                        if (lastPinnedGroupIndex >= pinnedGroups.length) {
                            lastPinnedGroupIndex = pinnedGroups.length - 1;
                        }
                        buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                    });

                    legendG.appendChild(legendItem);
                    legendY += 14;
                });

                if (hoverTrajectory && hoverLabel) {
                    drawSingleTrajectory(g, hoverTrajectory, hoverColor || "#999", maxProb, hoverLabel, true, chartInnerWidth);

                    var legendItem = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    legendItem.setAttribute("class", "legend-item hover-legend");
                    legendItem.setAttribute("transform", "translate(18, " + legendY + ")");

                    var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", "0"); line.setAttribute("y1", "0");
                    line.setAttribute("x2", "15"); line.setAttribute("y2", "0");
                    line.setAttribute("stroke", hoverColor || "#999");
                    line.setAttribute("stroke-width", "1.5");
                    line.setAttribute("stroke-dasharray", "4,2");
                    line.style.opacity = "0.7";
                    legendItem.appendChild(line);

                    var clipId = uid + "_hover_clip";
                    var clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                    clipPath.setAttribute("id", clipId);
                    var clipRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    clipRect.setAttribute("x", "20"); clipRect.setAttribute("y", "-10");
                    clipRect.setAttribute("width", inputTokenWidth - 45); clipRect.setAttribute("height", "20");
                    clipPath.appendChild(clipRect);
                    legendItem.appendChild(clipPath);

                    var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", "20"); text.setAttribute("y", "4");
                    text.setAttribute("font-size", "9"); text.setAttribute("fill", "#666");
                    text.setAttribute("clip-path", "url(#" + clipId + ")");
                    text.textContent = visualizeSpaces(hoverLabel);
                    legendItem.appendChild(text);

                    legendG.appendChild(legendItem);
                }
            }

            function drawSingleTrajectory(g, trajectory, color, maxProb, label, isHover, chartInnerWidth) {
                if (!trajectory || trajectory.length === 0) return;

                var dotRadius = isHover ? 2 : 3;
                var labelMargin = chartMargin.right;
                var usableWidth = chartInnerWidth - labelMargin;
                function layerToX(layerIdx) {
                    if (nLayers <= 1) return usableWidth / 2;
                    return dotRadius + (layerIdx / (nLayers - 1)) * (usableWidth - 2 * dotRadius);
                }

                var pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                if (isHover) pathEl.style.opacity = "0.7";

                var d = "";
                trajectory.forEach(function(p, layerIdx) {
                    var x = layerToX(layerIdx);
                    var y = chartInnerHeight - (p / maxProb) * chartInnerHeight;
                    d += (layerIdx === 0 ? "M" : "L") + x.toFixed(1) + "," + y.toFixed(1);
                });

                pathEl.setAttribute("d", d);
                pathEl.setAttribute("fill", "none");
                pathEl.setAttribute("stroke", color);
                pathEl.setAttribute("stroke-width", isHover ? "1.5" : "2");
                if (isHover) pathEl.setAttribute("stroke-dasharray", "4,2");
                g.appendChild(pathEl);

                currentVisibleIndices.forEach(function(layerIdx) {
                    var p = trajectory[layerIdx];
                    var x = layerToX(layerIdx);
                    var y = chartInnerHeight - (p / maxProb) * chartInnerHeight;

                    var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", x.toFixed(1));
                    circle.setAttribute("cy", y.toFixed(1));
                    circle.setAttribute("r", isHover ? 2 : 3);
                    circle.setAttribute("fill", color);
                    if (isHover) circle.style.opacity = "0.7";

                    var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title.textContent = (label || "") + " L" + widgetData.layers[layerIdx] + ": " + (p * 100).toFixed(2) + "%";
                    circle.appendChild(title);
                    g.appendChild(circle);
                });
            }

            // Global event listeners
            document.addEventListener("click", function(e) {
                if (!e.target.closest("#" + uid + " .popup") && !e.target.closest("#" + uid + " .pred-cell")) {
                    closePopup();
                }
                if (!e.target.closest("#" + uid + " .color-mode-btn") && !e.target.closest("#" + uid + "_color_menu")) {
                    document.getElementById(uid + "_color_menu").classList.remove("visible");
                }
            });

            document.getElementById(uid).addEventListener("mousedown", function(e) {
                if (e.shiftKey) e.preventDefault();
            });

            document.getElementById(uid).addEventListener("mouseleave", function() {
                currentHoverPos = widgetData.tokens.length - 1;
                var chartInnerWidth = updateChartDimensions();
                drawAllTrajectories(null, null, null, chartInnerWidth, currentHoverPos);
            });

            // Bottom resize handle for truncating rows
            (function() {
                var handle = document.getElementById(uid + "_resize_bottom");
                var table = document.getElementById(uid + "_table");
                var isDragging = false, startY = 0, startMaxRows = null;

                handle.addEventListener("mousedown", function(e) {
                    closePopup();
                    isDragging = true;
                    startY = e.clientY;
                    startMaxRows = currentMaxRows;
                    handle.classList.add("dragging");
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener("mousemove", function(e) {
                    if (!isDragging) return;
                    var delta = e.clientY - startY;
                    var rowHeight = 18;
                    var rowDelta = Math.round(delta / rowHeight);

                    var totalTokens = widgetData.tokens.length;
                    var startRows = startMaxRows === null ? totalTokens : startMaxRows;
                    var newMaxRows = startRows + rowDelta;
                    newMaxRows = Math.max(1, Math.min(totalTokens, newMaxRows));
                    if (newMaxRows >= totalTokens) newMaxRows = null;

                    if (newMaxRows !== currentMaxRows) {
                        buildTable(currentCellWidth, currentVisibleIndices, newMaxRows);
                    }
                });

                document.addEventListener("mouseup", function() {
                    if (isDragging) {
                        isDragging = false;
                        handle.classList.remove("dragging");
                    }
                });
            })();

            // Initial build with container width
            var containerWidth = getContainerWidth();
            var result = computeVisibleLayers(currentCellWidth, containerWidth);
            buildTable(currentCellWidth, result.indices, currentMaxRows);
        })();

        return { uid: uid };
    };
})();

// Create widget instance
LogitLensWidget("viz", data);
</script>
</body>
</html>
