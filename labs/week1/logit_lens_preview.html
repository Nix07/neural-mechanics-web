<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Logit Lens Visualization Preview</title>
    <script src="preview_data.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1000px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { font-size: 24px; margin-bottom: 20px; }
        .preview-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .note { font-size: 12px; color: #666; margin-bottom: 15px; }
    </style>
</head>
<body>
    <h1>Logit Lens Visualization Preview</h1>
    <p class="note">Using real Llama 3.1 70B data via NDIF. Open in browser - no notebook needed.</p>
    <div class="preview-container" id="viz">
        <style>
            #ll_preview {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                margin: 20px 0;
                position: relative;
                -webkit-user-select: none;
                user-select: none;
            }
            #ll_preview .ll-title { font-size: 16px; font-weight: 600; margin-bottom: 8px; }
            #ll_preview .color-mode-btn {
                display: inline-block; padding: 2px 4px; background: white;
                border-radius: 4px; font-size: 16px; cursor: pointer; color: #333;
                border: 1px solid #ccc;
            }
            #ll_preview .color-mode-btn:hover { background: #f5f5f5; }
            #ll_preview .ll-table { border-collapse: collapse; font-size: 10px; table-layout: fixed; }
            #ll_preview .ll-table td, #ll_preview .ll-table th { border: 1px solid #ddd; box-sizing: border-box; }
            #ll_preview .pred-cell {
                height: 22px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
                padding: 2px 4px; font-family: monospace; font-size: 9px; cursor: pointer; position: relative;
            }
            #ll_preview .pred-cell:hover { outline: 2px solid #e91e63; outline-offset: -1px; }
            #ll_preview .pred-cell.selected { background: #fff59d !important; color: #333 !important; }
            #ll_preview .input-token {
                padding: 2px 8px; text-align: right; font-weight: 500; color: #333;
                background: #f5f5f5; white-space: nowrap; overflow: hidden;
                text-overflow: ellipsis; font-family: monospace; font-size: 10px; cursor: pointer;
                position: relative;
            }
            #ll_preview .input-token:hover { background: #e8e8e8; }
            #ll_preview .layer-hdr {
                padding: 4px 2px; text-align: center; font-weight: 500; color: #666;
                background: #f5f5f5; font-size: 9px; position: relative;
            }
            #ll_preview .corner-hdr { padding: 4px 8px; text-align: right; font-weight: 500; color: #666; background: white; position: relative; }
            #ll_preview .chart-container { margin-top: 8px; background: #fafafa; border-radius: 4px; padding: 8px 0; }
            #ll_preview .chart-container svg { display: block; margin: 0; padding: 0; }
            #ll_preview .popup {
                display: none; position: absolute; background: white; border: 1px solid #ddd;
                border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px;
                z-index: 100; min-width: 180px; max-width: 280px;
            }
            #ll_preview .popup.visible { display: block; }
            #ll_preview .popup-header { font-weight: 600; font-size: 13px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee; }
            #ll_preview .popup-header code { font-weight: 400; font-size: 12px; background: #f5f5f5; padding: 2px 6px; border-radius: 3px; margin-left: 4px; }
            #ll_preview .popup-close { position: absolute; top: 8px; right: 10px; cursor: pointer; color: #999; font-size: 16px; }
            #ll_preview .popup-close:hover { color: #333; }
            #ll_preview .topk-item {
                padding: 4px 6px; margin: 2px 0; border-radius: 3px; cursor: pointer;
                display: flex; justify-content: space-between; font-size: 11px;
            }
            #ll_preview .topk-item:hover { background: #e3f2fd; }
            #ll_preview .topk-item.active { background: #bbdefb; }
            #ll_preview .topk-token { font-family: monospace; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            #ll_preview .topk-prob { color: #666; margin-left: 8px; }
            #ll_preview .topk-item.pinned { border-left: 3px solid currentColor; }
            #ll_preview .resize-handle {
                position: absolute; width: 6px; height: 100%; background: transparent;
                cursor: col-resize; right: -3px; top: 0; z-index: 10;
            }
            #ll_preview .resize-handle:hover, #ll_preview .resize-handle.dragging { background: rgba(33, 150, 243, 0.4); }
            #ll_preview .resize-handle-input {
                position: absolute; width: 6px; height: 100%; background: transparent;
                cursor: col-resize; right: -3px; top: 0; z-index: 10;
            }
            #ll_preview .resize-handle-input:hover, #ll_preview .resize-handle-input.dragging { background: rgba(76, 175, 80, 0.4); }
            #ll_preview .table-wrapper { position: relative; display: inline-block; }
            #ll_preview .resize-handle-bottom {
                position: absolute; bottom: 0; left: 0; right: 0; height: 6px;
                cursor: row-resize; background: transparent;
            }
            #ll_preview .resize-handle-bottom:hover, #ll_preview .resize-handle-bottom.dragging { background: rgba(33, 150, 243, 0.4); }
            #ll_preview .resize-hint { font-size: 9px; color: #999; margin-top: 4px; }
            #ll_preview .color-menu {
                display: none; position: absolute; background: white; border: 1px solid #ddd;
                border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 200; min-width: 150px;
            }
            #ll_preview .color-menu.visible { display: block; }
            #ll_preview .color-menu-item { padding: 8px 12px; cursor: pointer; font-size: 12px; }
            #ll_preview .color-menu-item:hover { background: #f0f0f0; }
            #ll_preview .legend-close { cursor: pointer; }
            #ll_preview .legend-close:hover { fill: #e91e63 !important; }
        </style>

        <div id="ll_preview">
            <div class="ll-title" id="ll_preview_title">Logit Lens: Top Predictions by Layer</div>
            <div class="table-wrapper">
                <table class="ll-table" id="ll_preview_table"></table>
                <div class="resize-handle-bottom" id="ll_preview_resize_bottom"></div>
            </div>
            <div class="resize-hint" id="ll_preview_resize_hint">drag column borders to resize</div>
            <div class="chart-container" id="ll_preview_chart_container">
                <svg id="ll_preview_chart" height="140"></svg>
            </div>
            <div class="popup" id="ll_preview_popup">
                <span class="popup-close" id="ll_preview_popup_close">&times;</span>
                <div class="popup-header">
                    Layer <span id="ll_preview_popup_layer"></span>, Position <span id="ll_preview_popup_pos"></span>
                </div>
                <div id="ll_preview_popup_content"></div>
            </div>
            <div class="color-menu" id="ll_preview_color_menu"></div>
        </div>
    </div>

<script>
// Use real data from NDIF via JSONP (preview_data.js)
const data = (typeof PREVIEW_DATA !== 'undefined') ? PREVIEW_DATA : {
    layers: [0, 1, 2, 3],
    tokens: ["Fallback", " data"],
    cells: [[{token:"test",prob:0.5,trajectory:[0.5,0.5,0.5,0.5],topk:[{token:"test",prob:0.5,trajectory:[0.5,0.5,0.5,0.5]}]}]]
};

(function() {
    const uid = "ll_preview";
    const nLayers = data.layers.length;
    const chartHeight = 140;
    const chartMargin = { top: 10, right: 8, bottom: 25, left: 10 };
    const chartInnerHeight = chartHeight - chartMargin.top - chartMargin.bottom;
    const minCellWidth = 10;  // Much smaller min
    const maxCellWidth = 200;

    let inputTokenWidth = 100;
    let currentCellWidth = 44;
    let currentVisibleIndices = [];
    let currentMaxRows = null;  // null = show all rows, otherwise limit to this many (always including last)
    let openPopupCell = null;
    let currentHoverPos = data.tokens.length - 1;
    let colorMode = "top";

    // Pinned groups: each group has a color and array of tokens whose probs are summed
    const pinnedGroups = [];  // [{color: "#...", tokens: ["token1", "token2"]}, ...]
    let lastPinnedGroupIndex = -1;  // Track which group to add to with shift-click
    const colors = ["#2196F3", "#e91e63", "#4CAF50", "#FF9800", "#9C27B0", "#00BCD4", "#F44336", "#8BC34A"];
    let colorIndex = 0;

    function getNextColor() {
        const c = colors[colorIndex % colors.length];
        colorIndex++;
        return c;
    }

    function getColorForToken(token) {
        for (const group of pinnedGroups) {
            if (group.tokens.includes(token)) return group.color;
        }
        return null;
    }

    function findGroupForToken(token) {
        for (let i = 0; i < pinnedGroups.length; i++) {
            if (pinnedGroups[i].tokens.includes(token)) return i;
        }
        return -1;
    }

    function getGroupLabel(group) {
        return group.tokens.map(t => visualizeSpaces(t)).join("+");
    }

    function getGroupTrajectory(group, pos) {
        // Sum probabilities across all tokens in the group
        const result = data.layers.map(() => 0);
        for (const token of group.tokens) {
            const traj = getTrajectoryForToken(token, pos);
            for (let i = 0; i < result.length; i++) {
                result[i] += traj[i];
            }
        }
        return result;
    }

    function getGroupProbAtLayer(group, pos, layerIdx) {
        // Sum probabilities of all tokens in group at specific layer
        let sum = 0;
        for (const token of group.tokens) {
            const traj = getTrajectoryForToken(token, pos);
            sum += traj[layerIdx] || 0;
        }
        return sum;
    }

    function getWinningGroupAtCell(pos, layerIdx) {
        // Find if any pinned group's summed probability beats the top-1 at this cell
        const cellData = data.cells[pos][layerIdx];
        const top1Prob = cellData.prob;
        let winningGroup = null;
        let winningProb = top1Prob;

        for (const group of pinnedGroups) {
            const groupProb = getGroupProbAtLayer(group, pos, layerIdx);
            if (groupProb > winningProb) {
                winningProb = groupProb;
                winningGroup = group;
            }
        }
        return winningGroup;
    }

    function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
    }

    function visualizeSpaces(text) {
        // Show leading/trailing spaces as modifier letter shelf (˽ U+02FD)
        let result = text;
        // Replace leading spaces
        let leadingSpaces = 0;
        while (leadingSpaces < result.length && result[leadingSpaces] === ' ') leadingSpaces++;
        if (leadingSpaces > 0) {
            result = '\u02FD'.repeat(leadingSpaces) + result.slice(leadingSpaces);
        }
        // Replace trailing spaces
        let trailingSpaces = 0;
        while (trailingSpaces < result.length && result[result.length - 1 - trailingSpaces] === ' ') trailingSpaces++;
        if (trailingSpaces > 0) {
            result = result.slice(0, result.length - trailingSpaces) + '\u02FD'.repeat(trailingSpaces);
        }
        return result;
    }

    function probToColor(prob, baseColor = null) {
        if (baseColor) {
            // Use the pinned color with varying intensity
            // Parse hex color to RGB
            const hex = baseColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            // Blend from white to the base color based on probability
            const blend = prob;
            const rr = Math.round(255 - (255 - r) * blend);
            const gg = Math.round(255 - (255 - g) * blend);
            const bb = Math.round(255 - (255 - b) * blend);
            return `rgb(${rr},${gg},${bb})`;
        }
        // Default blue gradient
        const r = Math.round(255 * (1 - prob * 0.8));
        const g = Math.round(255 * (1 - prob * 0.6));
        return `rgb(${r},${g},255)`;
    }

    function getTrajectoryForToken(token, pos) {
        for (let li = 0; li < data.cells[pos].length; li++) {
            const cellData = data.cells[pos][li];
            if (cellData.token === token) return cellData.trajectory;
            for (const tk of cellData.topk) {
                if (tk.token === token) return tk.trajectory;
            }
        }
        return data.layers.map(() => 0);
    }

    function computeVisibleLayers(cellWidth, containerWidth) {
        // Subtract 1px for table outer border (border-collapse still has outer edge)
        const availableWidth = containerWidth - inputTokenWidth - 1;
        // Use floor to get max columns that definitely fit
        const maxCols = Math.max(1, Math.floor(availableWidth / cellWidth));

        if (maxCols >= nLayers) {
            return { stride: 1, indices: data.layers.map((_, i) => i) };
        }

        // Calculate stride to maximize columns while fitting in maxCols
        // Use floor to get as many columns as possible, safety check handles overflow
        const stride = maxCols > 1
            ? Math.max(1, Math.floor((nLayers - 1) / (maxCols - 1)))
            : nLayers;

        const indices = [];
        const lastLayer = nLayers - 1;
        for (let i = lastLayer; i >= 0; i -= stride) {
            indices.unshift(i);
        }

        // Safety check: ensure we never exceed maxCols
        while (indices.length > maxCols) {
            indices.shift();
        }

        return { stride, indices };
    }

    function updateChartDimensions() {
        const table = document.getElementById(uid + "_table");
        const tableWidth = table.offsetWidth;
        const svg = document.getElementById(uid + "_chart");
        svg.setAttribute("width", tableWidth);

        // Compute actual chart width from DOM for precise alignment
        const firstInputCell = table.querySelector(".input-token");
        if (firstInputCell) {
            const tableRect = table.getBoundingClientRect();
            const inputCellRect = firstInputCell.getBoundingClientRect();
            const actualInputRight = inputCellRect.right - tableRect.left;
            return tableWidth - actualInputRight;
        }
        return tableWidth - inputTokenWidth;
    }

    function buildTable(cellWidth, visibleLayerIndices, maxRows = null) {
        currentVisibleIndices = visibleLayerIndices;
        currentMaxRows = maxRows;
        const table = document.getElementById(uid + "_table");
        let html = "";

        // Determine which token positions to show
        const totalTokens = data.tokens.length;
        let visiblePositions;
        if (maxRows === null || maxRows >= totalTokens) {
            visiblePositions = data.tokens.map((_, i) => i);
        } else {
            // Show last maxRows tokens (skip from beginning, always include last)
            const startPos = totalTokens - maxRows;
            visiblePositions = [];
            for (let i = startPos; i < totalTokens; i++) {
                visiblePositions.push(i);
            }
        }

        // Add colgroup to enforce column widths with table-layout: fixed
        html += "<colgroup>";
        html += `<col style="width:${inputTokenWidth}px;">`;
        visibleLayerIndices.forEach(() => {
            html += `<col style="width:${cellWidth}px;">`;
        });
        html += "</colgroup>";

        // Determine which columns get resize handles (up to halfway)
        const halfwayCol = Math.floor(visibleLayerIndices.length / 2);

        visiblePositions.forEach((pos, rowIdx) => {
            const tok = data.tokens[pos];
            const isFirstVisibleRow = rowIdx === 0;
            html += "<tr>";
            // Input token column with its own resize handle
            html += `<td class="input-token" data-pos="${pos}" title="${escapeHtml(tok)}" style="width:${inputTokenWidth}px; max-width:${inputTokenWidth}px;">`;
            html += `${escapeHtml(tok)}`;
            if (isFirstVisibleRow) {
                html += `<div class="resize-handle-input" data-col="-1"></div>`;
            }
            html += `</td>`;

            // Get base color for heatmap (if colorMode is a pinned token)
            const colorModeBaseColor = colorMode !== "top" ? getColorForToken(colorMode) : null;

            visibleLayerIndices.forEach((li, colIdx) => {
                const cellData = data.cells[pos][li];
                let cellProb = colorMode === "top" ? cellData.prob :
                    (cellData.topk.find(t => t.token === colorMode)?.prob || 0);

                const color = probToColor(cellProb, colorModeBaseColor);
                const textColor = cellProb < 0.5 ? "#333" : "#fff";
                // Check if top-1 token is pinned, or if a group wins by summed probability
                let pinnedColor = getColorForToken(cellData.token);
                if (!pinnedColor) {
                    const winningGroup = getWinningGroupAtCell(pos, li);
                    if (winningGroup) pinnedColor = winningGroup.color;
                }
                const pinnedStyle = pinnedColor ? `box-shadow: inset 0 0 0 2px ${pinnedColor};` : "";

                // Add resize handles to first visible row for columns up to halfway
                const hasHandle = isFirstVisibleRow && colIdx < halfwayCol;

                html += `<td class="pred-cell${pinnedColor ? ' pinned' : ''}" ` +
                    `data-pos="${pos}" data-li="${li}" data-col="${colIdx}" ` +
                    `style="background:${color}; color:${textColor}; width:${cellWidth}px; max-width:${cellWidth}px; ${pinnedStyle}">` +
                    `${escapeHtml(cellData.token)}`;
                if (hasHandle) {
                    html += `<div class="resize-handle" data-col="${colIdx}"></div>`;
                }
                html += `</td>`;
            });
            html += "</tr>";
        });

        // Footer row with layer numbers and resize handles
        html += "<tr>";
        html += `<th class="corner-hdr" style="width:${inputTokenWidth}px; max-width:${inputTokenWidth}px;">Layer<div class="resize-handle-input" data-col="-1"></div></th>`;
        visibleLayerIndices.forEach((li, colIdx) => {
            const hasHandle = colIdx < halfwayCol;
            html += `<th class="layer-hdr" style="width:${cellWidth}px; max-width:${cellWidth}px;">${data.layers[li]}`;
            if (hasHandle) {
                html += `<div class="resize-handle" data-col="${colIdx}"></div>`;
            }
            html += `</th>`;
        });
        html += "</tr>";

        table.innerHTML = html;
        attachCellListeners();
        attachResizeListeners();

        // Debug check: log if table exceeds container width
        const containerWidth = getContainerWidth();
        const actualTableWidth = table.offsetWidth;
        if (actualTableWidth > containerWidth) {
            console.log("Table width overflow detected:", {
                containerWidth,
                actualTableWidth,
                overflow: actualTableWidth - containerWidth,
                inputTokenWidth,
                cellWidth,
                nLayers,
                numVisibleCols: visibleLayerIndices.length,
                visibleLayerIndices,
                expectedTableWidth: inputTokenWidth + (visibleLayerIndices.length * cellWidth),
                availableForCols: containerWidth - inputTokenWidth,
                maxColsThatFit: Math.floor((containerWidth - inputTokenWidth) / cellWidth),
            });
        }

        const chartInnerWidth = updateChartDimensions();
        drawAllTrajectories(null, null, null, chartInnerWidth, currentHoverPos);
        updateTitle();

        const hint = document.getElementById(uid + "_resize_hint");
        const stride = visibleLayerIndices.length < nLayers ? Math.ceil(nLayers / visibleLayerIndices.length) : 1;
        hint.textContent = stride > 1 ?
            `showing every ${stride} layers ending at ${nLayers-1} (drag column borders to adjust)` :
            `showing all ${nLayers} layers`;
    }

    function updateTitle() {
        const titleEl = document.getElementById(uid + "_title");
        let displayLabel = "Top prediction";
        let pinnedColor = null;

        if (colorMode !== "top") {
            // Find the group containing this token and show full group label
            const groupIdx = findGroupForToken(colorMode);
            if (groupIdx >= 0) {
                const group = pinnedGroups[groupIdx];
                displayLabel = getGroupLabel(group);  // Shows all tokens with + and space viz
                pinnedColor = group.color;
            } else {
                // Token not in a group, just show it with space visualization
                displayLabel = visualizeSpaces(colorMode);
            }
        }

        // White background for "Top prediction", colored background for pinned tokens
        const btnStyle = pinnedColor ? `background: ${pinnedColor}22; border-color: ${pinnedColor};` : "";

        titleEl.innerHTML = `Logit Lens: Top Predictions by Layer <span class="color-mode-btn" id="${uid}_color_btn" style="${btnStyle}">(${escapeHtml(displayLabel)})</span>`;
        document.getElementById(uid + "_color_btn").addEventListener("click", showColorModeMenu);
    }

    function showColorModeMenu(e) {
        e.stopPropagation();
        const menu = document.getElementById(uid + "_color_menu");
        const btn = e.target;
        const rect = btn.getBoundingClientRect();
        const containerRect = document.getElementById(uid).getBoundingClientRect();

        menu.style.left = (rect.left - containerRect.left) + "px";
        menu.style.top = (rect.bottom - containerRect.top + 5) + "px";

        const lastPos = data.tokens.length - 1;
        const lastLayerIdx = currentVisibleIndices[currentVisibleIndices.length - 1];
        const topToken = data.cells[lastPos][lastLayerIdx].token;

        let html = `<div class="color-menu-item" data-mode="top">Top prediction</div>`;

        // Add final prediction token if not already pinned
        if (findGroupForToken(topToken) < 0) {
            html += `<div class="color-menu-item" data-mode="${escapeHtml(topToken)}">${escapeHtml(topToken)}</div>`;
        }

        // Add pinned tokens/groups
        pinnedGroups.forEach((group) => {
            const label = getGroupLabel(group);
            // Use first token as the mode identifier
            const modeToken = group.tokens[0];
            html += `<div class="color-menu-item" data-mode="${escapeHtml(modeToken)}" style="border-left: 3px solid ${group.color};">${escapeHtml(label)}</div>`;
        });

        menu.innerHTML = html;
        menu.classList.add("visible");

        menu.querySelectorAll(".color-menu-item").forEach(item => {
            item.addEventListener("click", (ev) => {
                ev.stopPropagation();
                colorMode = item.dataset.mode;
                menu.classList.remove("visible");
                buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
            });
        });
    }

    function getContainerWidth() {
        const container = document.getElementById(uid);
        return container.offsetWidth || 900;
    }

    function attachResizeListeners() {
        // Input column resize handles
        document.querySelectorAll(`#${uid} .resize-handle-input`).forEach(handle => {
            let isDragging = false, startX = 0, startWidth = inputTokenWidth;

            handle.addEventListener("mousedown", (e) => {
                closePopup();  // Dismiss popup on drag start
                isDragging = true;
                startX = e.clientX;
                startWidth = inputTokenWidth;
                handle.classList.add("dragging");
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener("mousemove", (e) => {
                if (!isDragging) return;
                const delta = e.clientX - startX;
                inputTokenWidth = Math.max(40, Math.min(200, startWidth + delta));
                // Recalculate visible layers since available width changed
                const { indices } = computeVisibleLayers(currentCellWidth, getContainerWidth());
                buildTable(currentCellWidth, indices, currentMaxRows);
            });

            document.addEventListener("mouseup", () => {
                if (isDragging) {
                    isDragging = false;
                    document.querySelectorAll(`#${uid} .resize-handle-input`).forEach(h => h.classList.remove("dragging"));
                }
            });
        });

        // Layer column resize handles
        document.querySelectorAll(`#${uid} .resize-handle`).forEach(handle => {
            const colIdx = parseInt(handle.dataset.col);
            let isDragging = false, startX = 0, startWidth = currentCellWidth;

            handle.addEventListener("mousedown", (e) => {
                closePopup();  // Dismiss popup on drag start
                isDragging = true;
                startX = e.clientX;
                startWidth = currentCellWidth;
                handle.classList.add("dragging");
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener("mousemove", (e) => {
                if (!isDragging) return;
                const delta = e.clientX - startX;
                // Number of columns to the left of this border (including this one)
                const numCols = colIdx + 1;
                // Each column changes by delta/numCols to make border move by delta pixels
                const widthDelta = delta / numCols;
                const newWidth = Math.max(minCellWidth, Math.min(maxCellWidth, startWidth + widthDelta));

                if (Math.abs(newWidth - currentCellWidth) > 1) {
                    currentCellWidth = newWidth;
                    const { indices } = computeVisibleLayers(currentCellWidth, getContainerWidth());
                    buildTable(currentCellWidth, indices, currentMaxRows);
                }
            });

            document.addEventListener("mouseup", () => {
                if (isDragging) {
                    isDragging = false;
                    document.querySelectorAll(`#${uid} .resize-handle`).forEach(h => h.classList.remove("dragging"));
                }
            });
        });
    }

    function attachCellListeners() {
        document.querySelectorAll(`#${uid} .pred-cell, #${uid} .input-token`).forEach(cell => {
            const pos = parseInt(cell.dataset.pos);
            if (isNaN(pos)) return;

            cell.addEventListener("mouseenter", () => {
                currentHoverPos = pos;
                const li = cell.dataset.li ? parseInt(cell.dataset.li) : 0;
                const cellData = data.cells[pos][li] || data.cells[pos][0];
                const chartInnerWidth = updateChartDimensions();
                const isPinned = findGroupForToken(cellData.token) >= 0;
                const hoverTraj = isPinned ? null : cellData.trajectory;
                const hoverColor = isPinned ? null : "#999";
                const hoverLabel = isPinned ? null : cellData.token;
                drawAllTrajectories(hoverTraj, hoverColor, hoverLabel, chartInnerWidth, pos);
            });
        });

        document.querySelectorAll(`#${uid} .pred-cell`).forEach(cell => {
            const pos = parseInt(cell.dataset.pos);
            const li = parseInt(cell.dataset.li);
            const cellData = data.cells[pos][li];

            cell.addEventListener("click", (e) => {
                e.stopPropagation();
                const addToGroup = e.shiftKey || e.ctrlKey || e.metaKey;
                if (e.shiftKey) {
                    togglePinnedTrajectory(cellData.token, addToGroup);
                    buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                    return;
                }
                if (openPopupCell === cell) { closePopup(); return; }
                document.querySelectorAll(`#${uid} .pred-cell.selected`).forEach(c => c.classList.remove("selected"));
                cell.classList.add("selected");
                showPopup(cell, pos, li, cellData);
            });
        });

        document.getElementById(uid + "_popup_close").addEventListener("click", closePopup);
    }

    function closePopup() {
        document.getElementById(uid + "_popup").classList.remove("visible");
        document.querySelectorAll(`#${uid} .pred-cell.selected`).forEach(c => c.classList.remove("selected"));
        openPopupCell = null;
    }

    function showPopup(cell, pos, li, cellData) {
        openPopupCell = cell;
        const popup = document.getElementById(uid + "_popup");
        const rect = cell.getBoundingClientRect();
        const containerRect = document.getElementById(uid).getBoundingClientRect();

        popup.style.left = (rect.left - containerRect.left + rect.width + 5) + "px";
        popup.style.top = (rect.top - containerRect.top) + "px";

        document.getElementById(uid + "_popup_layer").textContent = data.layers[li];
        document.getElementById(uid + "_popup_pos").innerHTML = pos + "<br>Input <code>" + escapeHtml(visualizeSpaces(data.tokens[pos])) + "</code>";

        let contentHtml = "";
        cellData.topk.forEach((item, ki) => {
            const probPct = (item.prob * 100).toFixed(1);
            const pinnedColor = getColorForToken(item.token);
            const pinnedStyle = pinnedColor ? `background: ${pinnedColor}22; border-left-color: ${pinnedColor};` : "";
            const visualizedToken = visualizeSpaces(item.token);
            contentHtml += `<div class="topk-item${pinnedColor ? ' pinned' : ''}" data-ki="${ki}" style="${pinnedStyle}">`;
            contentHtml += `<span class="topk-token" title="${escapeHtml(visualizedToken)}">${escapeHtml(visualizedToken)}</span>`;
            contentHtml += `<span class="topk-prob">${probPct}%</span>`;
            contentHtml += `</div>`;
        });

        document.getElementById(uid + "_popup_content").innerHTML = contentHtml;

        document.querySelectorAll(`#${uid}_popup_content .topk-item`).forEach(item => {
            const ki = parseInt(item.dataset.ki);
            const tokData = cellData.topk[ki];

            item.addEventListener("mouseenter", () => {
                document.querySelectorAll(`#${uid}_popup_content .topk-item`).forEach(it => it.classList.remove("active"));
                item.classList.add("active");
                const chartInnerWidth = updateChartDimensions();
                const isPinned = findGroupForToken(tokData.token) >= 0;
                const hoverTraj = isPinned ? null : tokData.trajectory;
                drawAllTrajectories(hoverTraj, "#999", tokData.token, chartInnerWidth, pos);
            });

            item.addEventListener("mouseleave", () => {
                const chartInnerWidth = updateChartDimensions();
                drawAllTrajectories(null, null, null, chartInnerWidth, pos);
            });

            item.addEventListener("click", (e) => {
                e.stopPropagation();
                const addToGroup = e.shiftKey || e.ctrlKey || e.metaKey;
                togglePinnedTrajectory(tokData.token, addToGroup);
                buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
                // Re-query cell after table rebuild (original cell reference is stale)
                const newCell = document.querySelector(`#${uid} .pred-cell[data-pos="${pos}"][data-li="${li}"]`);
                if (newCell) {
                    newCell.classList.add("selected");
                    showPopup(newCell, pos, li, cellData);
                }
            });
        });

        popup.classList.add("visible");
        const chartInnerWidth = updateChartDimensions();
        const isPinned = findGroupForToken(cellData.token) >= 0;
        const hoverTraj = isPinned ? null : cellData.trajectory;
        drawAllTrajectories(hoverTraj, "#999", cellData.token, chartInnerWidth, pos);
    }

    function togglePinnedTrajectory(token, addToGroup = false) {
        const existingGroupIdx = findGroupForToken(token);

        if (addToGroup && lastPinnedGroupIndex >= 0 && lastPinnedGroupIndex < pinnedGroups.length) {
            // Shift/ctrl/cmd click: add to or remove from the last pinned group
            const lastGroup = pinnedGroups[lastPinnedGroupIndex];

            if (existingGroupIdx === lastPinnedGroupIndex) {
                // Token is already in this group - remove it
                lastGroup.tokens = lastGroup.tokens.filter(t => t !== token);
                if (lastGroup.tokens.length === 0) {
                    // Group is now empty, remove it
                    pinnedGroups.splice(lastPinnedGroupIndex, 1);
                    lastPinnedGroupIndex = pinnedGroups.length - 1;
                }
                return false;
            } else if (existingGroupIdx >= 0) {
                // Token is in a different group - move it to last group
                pinnedGroups[existingGroupIdx].tokens = pinnedGroups[existingGroupIdx].tokens.filter(t => t !== token);
                if (pinnedGroups[existingGroupIdx].tokens.length === 0) {
                    pinnedGroups.splice(existingGroupIdx, 1);
                    if (lastPinnedGroupIndex > existingGroupIdx) lastPinnedGroupIndex--;
                }
                lastGroup.tokens.push(token);
                return true;
            } else {
                // Token not pinned - add to last group
                lastGroup.tokens.push(token);
                return true;
            }
        } else {
            // Normal click: toggle as individual pin
            if (existingGroupIdx >= 0) {
                // Remove from its group
                const group = pinnedGroups[existingGroupIdx];
                group.tokens = group.tokens.filter(t => t !== token);
                if (group.tokens.length === 0) {
                    pinnedGroups.splice(existingGroupIdx, 1);
                    if (lastPinnedGroupIndex >= pinnedGroups.length) {
                        lastPinnedGroupIndex = pinnedGroups.length - 1;
                    }
                }
                return false;
            } else {
                // Create new group with just this token
                const newGroup = { color: getNextColor(), tokens: [token] };
                pinnedGroups.push(newGroup);
                lastPinnedGroupIndex = pinnedGroups.length - 1;
                return true;
            }
        }
    }

    function drawAllTrajectories(hoverTrajectory, hoverColor, hoverLabel, chartInnerWidth, pos) {
        const svg = document.getElementById(uid + "_chart");
        svg.innerHTML = "";

        // Get actual input column right edge from DOM for precise alignment
        const table = document.getElementById(uid + "_table");
        const firstInputCell = table.querySelector(".input-token");
        const tableRect = table.getBoundingClientRect();
        const inputCellRect = firstInputCell.getBoundingClientRect();
        const actualInputRight = inputCellRect.right - tableRect.left;

        const legendG = document.createElementNS("http://www.w3.org/2000/svg", "g");
        legendG.setAttribute("class", "legend-area");
        svg.appendChild(legendG);

        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("transform", `translate(${actualInputRight},${chartMargin.top})`);
        svg.appendChild(g);

        // X axis line
        const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
        xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", chartInnerHeight);
        xAxis.setAttribute("x2", chartInnerWidth); xAxis.setAttribute("y2", chartInnerHeight);
        xAxis.setAttribute("stroke", "#ccc");
        g.appendChild(xAxis);

        // X axis layer labels under dots (with striding if too close)
        const dotRadius = 3;
        const labelMargin = chartMargin.right;  // Space for rightmost label
        const usableWidth = chartInnerWidth - labelMargin;
        function layerToXForLabels(layerIdx) {
            if (nLayers <= 1) return usableWidth / 2;
            return dotRadius + (layerIdx / (nLayers - 1)) * (usableWidth - 2 * dotRadius);
        }

        // Calculate label stride based on available space (min ~25px per label)
        // Stride from the right so last label is always shown, and always show first label
        const minLabelSpacing = 25;
        const totalLabelsWidth = currentVisibleIndices.length * minLabelSpacing;
        let labelStride = 1;
        if (totalLabelsWidth > usableWidth) {
            labelStride = Math.ceil(totalLabelsWidth / usableWidth);
        }

        // Build set of indices to show: stride from right, always include first
        const lastIdx = currentVisibleIndices.length - 1;
        const showAtIndex = new Set();
        // Stride from the right (last is always shown)
        for (let i = lastIdx; i >= 0; i -= labelStride) {
            showAtIndex.add(i);
        }
        // Always show first (index 0)
        showAtIndex.add(0);
        // If first and next-shown would be scrunched, remove the next-shown
        if (labelStride > 1) {
            // Find the smallest strided index > 0; if it's < labelStride, it's too close to 0
            for (let i = lastIdx; i > 0; i -= labelStride) {
                if (i < labelStride) {
                    showAtIndex.delete(i);
                    break;
                }
            }
        }

        currentVisibleIndices.forEach((layerIdx, i) => {
            if (showAtIndex.has(i)) {
                const x = layerToXForLabels(layerIdx);
                const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                label.setAttribute("x", x);
                label.setAttribute("y", chartInnerHeight + 12);
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("font-size", "9");
                label.setAttribute("fill", "#666");
                label.textContent = data.layers[layerIdx];
                g.appendChild(label);
            }
        });

        // Y axis line (draggable to resize input column)
        const yAxisGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        yAxisGroup.style.cursor = "col-resize";

        // Invisible wider hit target for easier dragging
        const yAxisHitTarget = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        yAxisHitTarget.setAttribute("x", -4); yAxisHitTarget.setAttribute("y", 0);
        yAxisHitTarget.setAttribute("width", 8); yAxisHitTarget.setAttribute("height", chartInnerHeight);
        yAxisHitTarget.setAttribute("fill", "transparent");
        yAxisGroup.appendChild(yAxisHitTarget);

        const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
        yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0);
        yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", chartInnerHeight);
        yAxis.setAttribute("stroke", "#ccc");
        yAxisGroup.appendChild(yAxis);
        g.appendChild(yAxisGroup);

        // Make Y-axis draggable to resize input column
        let yAxisDragging = false, yAxisStartX = 0, yAxisStartWidth = inputTokenWidth;
        yAxisGroup.addEventListener("mousedown", (e) => {
            closePopup();
            yAxisDragging = true;
            yAxisStartX = e.clientX;
            yAxisStartWidth = inputTokenWidth;
            yAxis.setAttribute("stroke", "rgba(76, 175, 80, 0.6)");
            e.preventDefault();
            e.stopPropagation();
        });
        document.addEventListener("mousemove", (e) => {
            if (!yAxisDragging) return;
            const delta = e.clientX - yAxisStartX;
            inputTokenWidth = Math.max(40, Math.min(200, yAxisStartWidth + delta));
            const { indices } = computeVisibleLayers(currentCellWidth, getContainerWidth());
            buildTable(currentCellWidth, indices, currentMaxRows);
        });
        document.addEventListener("mouseup", () => {
            if (yAxisDragging) {
                yAxisDragging = false;
            }
        });

        // Y axis label (vertical)
        const yLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
        yLabel.setAttribute("x", -chartInnerHeight / 2);
        yLabel.setAttribute("y", -actualInputRight + 15);
        yLabel.setAttribute("text-anchor", "middle");
        yLabel.setAttribute("font-size", "10");
        yLabel.setAttribute("fill", "#666");
        yLabel.setAttribute("transform", "rotate(-90)");
        yLabel.textContent = "Probability";
        svg.appendChild(yLabel);

        let allProbs = [];
        pinnedGroups.forEach((group) => {
            const traj = getGroupTrajectory(group, pos);
            allProbs.push(...traj);
        });
        if (hoverTrajectory) allProbs.push(...hoverTrajectory);
        const maxProb = Math.max(...allProbs, 0.1);

        let legendY = chartMargin.top + 10;
        pinnedGroups.forEach((group, groupIdx) => {
            const traj = getGroupTrajectory(group, pos);
            const groupLabel = getGroupLabel(group);
            drawSingleTrajectory(g, traj, group.color, maxProb, groupLabel, false, chartInnerWidth);

            const legendItem = document.createElementNS("http://www.w3.org/2000/svg", "g");
            legendItem.setAttribute("transform", `translate(18, ${legendY})`);
            legendItem.style.cursor = "pointer";

            // Invisible hit target rectangle covering the full legend width
            const hitTarget = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            hitTarget.setAttribute("x", "-15"); hitTarget.setAttribute("y", "-8");
            hitTarget.setAttribute("width", inputTokenWidth - 5); hitTarget.setAttribute("height", "14");
            hitTarget.setAttribute("fill", "transparent");
            legendItem.appendChild(hitTarget);

            // Close button to the left of the line
            const closeBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
            closeBtn.setAttribute("class", "legend-close");
            closeBtn.setAttribute("x", "-12"); closeBtn.setAttribute("y", "4");
            closeBtn.setAttribute("font-size", "16"); closeBtn.setAttribute("fill", "#999");
            closeBtn.style.display = "none";
            closeBtn.textContent = "×";
            legendItem.appendChild(closeBtn);

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", "0"); line.setAttribute("y1", "0");
            line.setAttribute("x2", "15"); line.setAttribute("y2", "0");
            line.setAttribute("stroke", group.color); line.setAttribute("stroke-width", "2");
            legendItem.appendChild(line);

            // Use clipPath for pixel-based text clipping
            const clipId = `${uid}_legend_clip_${groupIdx}`;
            const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
            clipPath.setAttribute("id", clipId);
            const clipRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            clipRect.setAttribute("x", "20"); clipRect.setAttribute("y", "-10");
            clipRect.setAttribute("width", inputTokenWidth - 45); clipRect.setAttribute("height", "20");
            clipPath.appendChild(clipRect);
            legendItem.appendChild(clipPath);

            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", "20"); text.setAttribute("y", "4");
            text.setAttribute("font-size", "9"); text.setAttribute("fill", "#333");
            text.setAttribute("clip-path", `url(#${clipId})`);
            text.textContent = groupLabel;  // Full label, clipped by pixel width
            legendItem.appendChild(text);

            legendItem.addEventListener("mouseenter", () => { closeBtn.style.display = "block"; });
            legendItem.addEventListener("mouseleave", () => { closeBtn.style.display = "none"; });
            closeBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                pinnedGroups.splice(groupIdx, 1);
                if (lastPinnedGroupIndex >= pinnedGroups.length) {
                    lastPinnedGroupIndex = pinnedGroups.length - 1;
                }
                buildTable(currentCellWidth, currentVisibleIndices, currentMaxRows);
            });

            legendG.appendChild(legendItem);
            legendY += 14;
        });

        if (hoverTrajectory && hoverLabel) {
            drawSingleTrajectory(g, hoverTrajectory, hoverColor || "#999", maxProb, hoverLabel, true, chartInnerWidth);

            // Add legend entry for hover trajectory
            const legendItem = document.createElementNS("http://www.w3.org/2000/svg", "g");
            legendItem.setAttribute("class", "legend-item hover-legend");
            legendItem.setAttribute("transform", `translate(18, ${legendY})`);

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", "0"); line.setAttribute("y1", "0");
            line.setAttribute("x2", "15"); line.setAttribute("y2", "0");
            line.setAttribute("stroke", hoverColor || "#999");
            line.setAttribute("stroke-width", "1.5");
            line.setAttribute("stroke-dasharray", "4,2");
            line.style.opacity = "0.7";
            legendItem.appendChild(line);

            // Use clipPath for pixel-based text clipping
            const clipId = `${uid}_hover_clip`;
            const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
            clipPath.setAttribute("id", clipId);
            const clipRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            clipRect.setAttribute("x", "20"); clipRect.setAttribute("y", "-10");
            clipRect.setAttribute("width", inputTokenWidth - 45); clipRect.setAttribute("height", "20");
            clipPath.appendChild(clipRect);
            legendItem.appendChild(clipPath);

            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", "20"); text.setAttribute("y", "4");
            text.setAttribute("font-size", "9"); text.setAttribute("fill", "#666");
            text.setAttribute("clip-path", `url(#${clipId})`);
            text.textContent = visualizeSpaces(hoverLabel);  // Full label with space viz, clipped
            legendItem.appendChild(text);

            legendG.appendChild(legendItem);
        }
    }

    function drawSingleTrajectory(g, trajectory, color, maxProb, label, isHover, chartInnerWidth) {
        if (!trajectory || trajectory.length === 0) return;

        const dotRadius = isHover ? 2 : 3;
        // All layers evenly spaced, with margin for dot radius at edges and label margin at right
        const labelMargin = chartMargin.right;
        const usableWidth = chartInnerWidth - labelMargin;
        function layerToX(layerIdx) {
            if (nLayers <= 1) return usableWidth / 2;
            return dotRadius + (layerIdx / (nLayers - 1)) * (usableWidth - 2 * dotRadius);
        }

        const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
        if (isHover) pathEl.style.opacity = "0.7";

        // Draw line through ALL layers
        let d = "";
        trajectory.forEach((p, layerIdx) => {
            const x = layerToX(layerIdx);
            const y = chartInnerHeight - (p / maxProb) * chartInnerHeight;
            d += (layerIdx === 0 ? "M" : "L") + x.toFixed(1) + "," + y.toFixed(1);
        });

        pathEl.setAttribute("d", d);
        pathEl.setAttribute("fill", "none");
        pathEl.setAttribute("stroke", color);
        pathEl.setAttribute("stroke-width", isHover ? "1.5" : "2");
        if (isHover) pathEl.setAttribute("stroke-dasharray", "4,2");
        g.appendChild(pathEl);

        // Draw dots at visible layer positions, using same layerToX as line
        currentVisibleIndices.forEach((layerIdx) => {
            const p = trajectory[layerIdx];
            const x = layerToX(layerIdx);
            const y = chartInnerHeight - (p / maxProb) * chartInnerHeight;

            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x.toFixed(1));
            circle.setAttribute("cy", y.toFixed(1));
            circle.setAttribute("r", isHover ? 2 : 3);
            circle.setAttribute("fill", color);
            if (isHover) circle.style.opacity = "0.7";

            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.textContent = (label || "") + " L" + data.layers[layerIdx] + ": " + (p * 100).toFixed(2) + "%";
            circle.appendChild(title);
            g.appendChild(circle);
        });
    }

    // Global event listeners
    document.addEventListener("click", (e) => {
        if (!e.target.closest(`#${uid} .popup`) && !e.target.closest(`#${uid} .pred-cell`)) {
            closePopup();
        }
        if (!e.target.closest(`#${uid} .color-mode-btn`) && !e.target.closest(`#${uid}_color_menu`)) {
            document.getElementById(uid + "_color_menu").classList.remove("visible");
        }
    });

    document.getElementById(uid).addEventListener("mousedown", (e) => {
        if (e.shiftKey) e.preventDefault();
    });

    document.getElementById(uid).addEventListener("mouseleave", () => {
        currentHoverPos = data.tokens.length - 1;
        const chartInnerWidth = updateChartDimensions();
        drawAllTrajectories(null, null, null, chartInnerWidth, currentHoverPos);
    });

    // Bottom resize handle for truncating rows
    (function() {
        const handle = document.getElementById(uid + "_resize_bottom");
        const table = document.getElementById(uid + "_table");
        let isDragging = false, startY = 0, startMaxRows = null;

        handle.addEventListener("mousedown", (e) => {
            closePopup();
            isDragging = true;
            startY = e.clientY;
            startMaxRows = currentMaxRows;
            handle.classList.add("dragging");
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            const delta = e.clientY - startY;
            const rowHeight = 18;  // Approximate row height
            const rowDelta = Math.round(delta / rowHeight);

            const totalTokens = data.tokens.length;
            const startRows = startMaxRows === null ? totalTokens : startMaxRows;
            // Dragging up (negative delta) reduces rows; dragging down increases rows
            let newMaxRows = startRows + rowDelta;
            // Clamp to valid range (at least 1 row, at most all rows)
            newMaxRows = Math.max(1, Math.min(totalTokens, newMaxRows));
            // If showing all rows, use null
            if (newMaxRows >= totalTokens) newMaxRows = null;

            if (newMaxRows !== currentMaxRows) {
                buildTable(currentCellWidth, currentVisibleIndices, newMaxRows);
            }
        });

        document.addEventListener("mouseup", () => {
            if (isDragging) {
                isDragging = false;
                handle.classList.remove("dragging");
            }
        });
    })();

    // Initial build with container width
    const containerWidth = getContainerWidth();
    const { indices } = computeVisibleLayers(currentCellWidth, containerWidth);
    buildTable(currentCellWidth, indices, currentMaxRows);
})();
</script>
</body>
</html>
